<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HAF Übersichtskarte</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    /* Weißer Hintergrund */
    html,body { height:100%; margin:0; background:#ffffff; } 
    #map { width:100%; height:100vh; background:#ffffff; } 

    /* Legend */
    .legend { background: white; padding:8px 10px; border-radius:6px; box-shadow:0 1px 6px rgba(0,0,0,0.15); font-size:14px; }
    .legend .item { display:flex; align-items:center; gap:8px; margin-bottom:6px; }
    .legend .swatch { width:18px; height:12px; border-radius:2px; display:inline-block; }

    /* Tooltips immer ganz oben */
    .leaflet-tooltip {
      z-index: 100000 !important;
      pointer-events: none;
    }

    @media (max-width:700px){ .legend { font-size:13px; padding:6px 8px; } }
  </style>
</head>
<body>
<div id="map" role="application" aria-label="Interaktive Übersichtskarte"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
/* === Konfiguration === */
const REGIONS_GEOJSON_FILE = 'regionen.geojson';
const AUSTRIA_GEOJSON_FILE = 'bundeslaender.geojson';

/* Farben */
const COLOR_FORERUNNER = "#7b8ca0";
const COLOR_FOLLOWER   = "#a1bdda";
const COLOR_DEFAULT    = "#6c757d";

/* Link-Felder Reihenfolge, falls unterschiedlich benannt */
const LINK_CANDIDATES = ['url','website','link','homepage','href','site','website_url','portal','web','uri','home'];

/* Karte (kein TileLayer) */
const map = L.map('map', { minZoom: 6, maxZoom: 13, scrollWheelZoom: true }).setView([47.5,13.3],7);

/* Panes: country behind, regions in front */
map.createPane('countryPane'); map.getPane('countryPane').style.zIndex = 200;
map.createPane('regionsPane'); map.getPane('regionsPane').style.zIndex = 650;
// ensure tooltip pane is above regions
if (map.getPane('tooltipPane')) map.getPane('tooltipPane').style.zIndex = 1200;

/* Helpers: open in top-most window (replaces whole window even if in iframe) */
function openInTopWindow(url) {
  if (!url) return false;
  url = url.toString().trim();
  // relative path -> same origin, navigate top
  if (/^\/[^\/]/.test(url)) { try { window.top.location.href = url; } catch(e){ window.location.href = url; } return true; }
  if (!/^[a-zA-Z]+:\/\//.test(url)) url = 'https://' + url;
  try { window.top.location.href = url; } catch(e) { window.location.href = url; }
  return true;
}

/* Styles */
function austriaStyle(feature) {
  return {
    color: '#ffffff',
    weight: 2,
    fillColor: '#e1e1e1',
    fillOpacity: 1,
    interactive: false,
    pane: 'countryPane'
  };
}
function styleByType(feature) {
  const t = (feature.properties && feature.properties.type || '').toLowerCase();
  let fill = COLOR_DEFAULT;
  if (t === 'forerunner') fill = COLOR_FORERUNNER;
  if (t === 'follower')   fill = COLOR_FOLLOWER;
  return {
    color: '#ffffff',
    weight: 2,             // region stroke = 2
    fillColor: fill,
    fillOpacity: 1,
    className: 'region-polygon',
    pane: 'regionsPane'
  };
}

/* --- Fit bounds settings (robust, outlier-resistant) --- */
const MAX_FITBOUNDS_ZOOM = 13;   // maximale erlaubte Zoomstufe
const FIT_PADDING = [0,0];       // kein Padding -> tight
const OUTLIER_CUT_PERCENT = 2.5; // entferne untere/obere 2.5% Koordinaten-Extremwerte

/**
 * Flatten GeoJSON geometry coordinates into array of [lng,lat] pairs.
 */
function collectCoordinatesFromGeoJSON(geojson) {
  const coords = [];
  function walkGeom(g) {
    if (!g) return;
    const type = g.type;
    if (type === 'Point') coords.push(g.coordinates);
    else if (type === 'MultiPoint' || type === 'LineString') {
      g.coordinates.forEach(c => coords.push(c));
    } else if (type === 'MultiLineString' || type === 'Polygon') {
      g.coordinates.forEach(arr => arr.forEach(c => coords.push(c)));
    } else if (type === 'MultiPolygon') {
      g.coordinates.forEach(poly => poly.forEach(ring => ring.forEach(c => coords.push(c))));
    } else if (type === 'GeometryCollection') {
      g.geometries.forEach(gg => walkGeom(gg));
    }
  }
  if (geojson.type === 'FeatureCollection') {
    geojson.features.forEach(f => walkGeom(f.geometry));
  } else if (geojson.type === 'Feature') {
    walkGeom(geojson.geometry);
  } else {
    walkGeom(geojson);
  }
  return coords; // array of [lng,lat]
}

/**
 * Compute percentile (p in [0,100]) for sorted numeric array.
 */
function percentile(sortedArr, p) {
  if (!sortedArr.length) return null;
  const idx = (p/100) * (sortedArr.length - 1);
  const lower = Math.floor(idx);
  const upper = Math.ceil(idx);
  if (lower === upper) return sortedArr[lower];
  const weight = idx - lower;
  return sortedArr[lower] * (1 - weight) + sortedArr[upper] * weight;
}

/**
 * Compute robust bounds by trimming extreme coordinate percentiles.
 * Falls keine ausreichenden Koordinaten vorhanden, gibt null zurück.
 */
function computeRobustBounds(geojson) {
  const coords = collectCoordinatesFromGeoJSON(geojson);
  if (!coords || coords.length === 0) return null;

  const lons = coords.map(c => c[0]).filter(x => isFinite(x)).sort((a,b)=>a-b);
  const lats = coords.map(c => c[1]).filter(x => isFinite(x)).sort((a,b)=>a-b);

  // if too few points, fallback to raw min/max
  if (lons.length < 6 || lats.length < 6) {
    const minLon = lons[0], maxLon = lons[lons.length-1];
    const minLat = lats[0], maxLat = lats[lats.length-1];
    return L.latLngBounds([[minLat,minLon],[maxLat,maxLon]]);
  }

  const lowerPct = OUTLIER_CUT_PERCENT;
  const upperPct = 100 - OUTLIER_CUT_PERCENT;

  const minLon = percentile(lons, lowerPct);
  const maxLon = percentile(lons, upperPct);
  const minLat = percentile(lats, lowerPct);
  const maxLat = percentile(lats, upperPct);

  // Safety: ensure min < max
  if (!(isFinite(minLon) && isFinite(maxLon) && isFinite(minLat) && isFinite(maxLat) && minLon < maxLon && minLat < maxLat)) {
    // fallback to raw bounds
    const rawMinLon = lons[0], rawMaxLon = lons[lons.length-1];
    const rawMinLat = lats[0], rawMaxLat = lats[lats.length-1];
    return L.latLngBounds([[rawMinLat,rawMinLon],[rawMaxLat,rawMaxLon]]);
  }

  return L.latLngBounds([[minLat,minLon],[maxLat,maxLon]]);
}

let austriaBounds = null;
fetch(AUSTRIA_GEOJSON_FILE)
  .then(r => { if (!r.ok) throw new Error('Fehler beim Laden der Bundesländer: ' + r.status); return r.json(); })
  .then(data => {
    const bl = L.geoJSON(data, { style: austriaStyle, interactive: false, pane: 'countryPane' }).addTo(map);
    try {
      // robust bounds calculation (removes coordinate outliers)
      const robustBounds = computeRobustBounds(data);
      if (robustBounds && robustBounds.isValid && !robustBounds.isEmpty()) {
        austriaBounds = robustBounds;
        console.log('Verwende robuste Bounds (Outlier-Cut ' + OUTLIER_CUT_PERCENT + '%):', austriaBounds.toBBoxString());
      } else {
        austriaBounds = bl.getBounds();
        console.log('Robuste Bounds fehlgeschlagen, fallback auf raw getBounds():', austriaBounds.toBBoxString());
      }

      // tighten logic: compute best zoom that fills bounds (no padding)
      function fitAustriaTight() {
        try { map.invalidateSize(); } catch(e){}
        if (!austriaBounds || !austriaBounds.isValid || austriaBounds.isEmpty()) return;

        // Best zoom to fit exactly the bounds into the current map size (no padding)
        const bestZoom = map.getBoundsZoom(austriaBounds, false);

        // Limit zoom to allowed maximum
        const zoomTo = Math.min(bestZoom, MAX_FITBOUNDS_ZOOM);

        // Set view to center with exact zoom (stable)
        map.setView(austriaBounds.getCenter(), zoomTo, { animate: false });

        // As extra assurance, call fitBounds with zero padding (minor timeout helps with some layouts)
        setTimeout(() => {
          try {
            map.fitBounds(austriaBounds, { padding: FIT_PADDING, maxZoom: MAX_FITBOUNDS_ZOOM, animate: false });
          } catch(e){}
        }, 20);
      }

      // initial tight fit
      setTimeout(fitAustriaTight, 150);

      // adjust on resize
      window.addEventListener('resize', () => {
        setTimeout(()=> {
          fitAustriaTight();
        }, 150);
      });

    } catch (e) {
      console.warn('Fehler beim Berechnen der Bounds:', e);
    }
  })
  .catch(err => {
    console.warn('bundeslaender.geojson konnte nicht geladen werden:', err);
  });

/* --- Regions (interactive) --- */
window.regionsLayer = null;

function onEachRegion(feature, layer) {
  const type = (feature.properties && feature.properties.type || '').toLowerCase();
  const name = (feature.properties && feature.properties.name) ? feature.properties.name : '(kein Name)';
  let prefix = '';
  if (type === 'forerunner') prefix = 'Forerunner-Region ';
  else if (type === 'follower') prefix = 'Follower-Region ';
  // tooltip without colon; ensure it uses tooltipPane
  layer.bindTooltip(prefix + name, { sticky: true, direction: 'auto', pane: 'tooltipPane' });

  layer.on({
    mouseover(e) {
      e.target.setStyle({ weight: 3, fillOpacity: 1 });
      if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) e.target.bringToFront();
    },
    mouseout(e) {
      if (window.regionsLayer) window.regionsLayer.resetStyle(e.target);
    },
    click(e) {
      const props = (feature.properties || {});
      for (const k of LINK_CANDIDATES) {
        if (props[k] && props[k].toString && props[k].toString().trim().length) {
          openInTopWindow(props[k]); return;
        }
      }
      if (props.slug && props.slug.toString().trim()) { openInTopWindow('/' + props.slug.toString().trim()); return; }
      if (e.target && e.target.getBounds) map.fitBounds(e.target.getBounds(), { padding: FIT_PADDING, maxZoom: MAX_FITBOUNDS_ZOOM });
    }
  });
}

function createRegionsLayer(data) {
  window.regionsLayer = L.geoJSON(data, {
    style: styleByType,
    onEachFeature: onEachRegion,
    pane: 'regionsPane'
  }).addTo(map);
}

/* pointer-events enforcement */
function enforcePointerEventsOnRegions() {
  try {
    if (!window.regionsLayer) {
      document.querySelectorAll('#map svg').forEach(sv => {
        sv.style.pointerEvents = 'auto';
        sv.querySelectorAll('g').forEach(g => { g.style.pointerEvents = 'auto'; });
        sv.querySelectorAll('path').forEach(p => { p.style.pointerEvents = 'auto'; p.style.cursor = 'pointer'; });
      });
      return;
    }
    window.regionsLayer.eachLayer(function(layer){
      if (layer && layer._path) {
        layer._path.style.pointerEvents = 'auto';
        layer._path.style.cursor = 'pointer';
      }
    });
  } catch (err) { console.warn('enforcePointerEventsOnRegions error', err); }
}

/* DOM fallback on path click - uses top window */
function attachDomFallbackToRegions() {
  try {
    if (!window.regionsLayer || typeof window.regionsLayer.eachLayer !== 'function') return;
    window.regionsLayer.eachLayer(function(layer){
      try {
        if (layer && layer._path && !layer._path.__domClickAttached) {
          layer._path.addEventListener('click', function(evt){
            try {
              const props = (layer.feature && layer.feature.properties) ? layer.feature.properties : {};
              for (const k of LINK_CANDIDATES) {
                if (props[k] && props[k].toString && props[k].toString().trim().length) { openInTopWindow(props[k]); return; }
              }
              if (props.slug && props.slug.toString().trim()) { openInTopWindow('/' + props.slug.toString().trim()); return; }
            } catch(e) { console.warn('DOM-Fallback handler error', e); }
          }, false);
          layer._path.__domClickAttached = true;
        }
      } catch(e){}
    });
  } catch (err) { console.warn('attachDomFallbackToRegions error', err); }
}

/* global path->layer handler for regions only (uses top window) */
(function attachGlobalPathClickHandlerForRegions(){
  const mapEl = document.getElementById('map');
  if (!mapEl) return;
  const handler = function(e){
    try {
      const el = document.elementFromPoint(e.clientX, e.clientY);
      let path = el;
      while (path && path.tagName !== 'path') path = path.parentElement || path.parentNode;
      if (!path) return;
      const candidateLayers = (window.regionsLayer && typeof window.regionsLayer.getLayers === 'function') ? window.regionsLayer.getLayers() : [];
      const pid = path._leaflet_id;
      const layer = candidateLayers.find(l => l && (l._path === path || l._leaflet_id === pid || (l._path && l._path._leaflet_id === pid)));
      if (!layer) return;
      const props = (layer.feature && layer.feature.properties) ? layer.feature.properties : {};
      for (const k of LINK_CANDIDATES) {
        if (props[k] && props[k].toString && props[k].toString().trim().length) {
          openInTopWindow(props[k]); return;
        }
      }
      if (props.slug && props.slug.toString().trim()) { openInTopWindow('/' + props.slug.toString().trim()); return; }
    } catch (err) { /* ignore */ }
  };
  mapEl.addEventListener('click', handler, true);
  console.log('Global regions-only path->layer click handler attached (top-window).');
})();

/* Load regions */
fetch(REGIONS_GEOJSON_FILE)
  .then(r => { if (!r.ok) throw new Error('Fehler beim Laden der Regionen: ' + r.status); return r.json(); })
  .then(data => {
    if (!data || !data.features) throw new Error('Keine Features in Regionen gefunden');
    createRegionsLayer(data);
    setTimeout(()=>map.invalidateSize(), 200);
    enforcePointerEventsOnRegions();
    attachDomFallbackToRegions();
    map.on('zoomend moveend layeradd layerremove', function(){
      enforcePointerEventsOnRegions();
      attachDomFallbackToRegions();
    });
    // MutationObserver on overlay-pane
    const overlay = document.querySelector('.leaflet-pane.leaflet-overlay-pane');
    if (overlay) {
      const mo = new MutationObserver(() => {
        if (window.__pe_timeout) clearTimeout(window.__pe_timeout);
        window.__pe_timeout = setTimeout(function(){
          enforcePointerEventsOnRegions();
          attachDomFallbackToRegions();
        }, 80);
      });
      mo.observe(overlay, { childList:true, subtree:true, attributes:true });
    }
  })
  .catch(err => {
    console.error('Fehler beim Laden der Regionen:', err);
  });

/* Legend */
const legend = L.control({ position: 'bottomright' });
legend.onAdd = function(){
  const div = L.DomUtil.create('div','legend');
  div.innerHTML = '<strong>Legende</strong>';
  const add = (color,label) => {
    const item = document.createElement('div');
    item.className = 'item';
    const sw = document.createElement('span');
    sw.className = 'swatch';
    sw.style.background = color;
    const txt = document.createElement('span');
    txt.textContent = label;
    item.appendChild(sw);
    item.appendChild(txt);
    div.appendChild(item);
  };
  add(COLOR_FORERUNNER, 'Forerunner-Region');
  add(COLOR_FOLLOWER, 'Follower-Region');
  return div;
};
legend.addTo(map);

/* Accessibility: Enter opens link for region under map center (top window) */
document.addEventListener('keydown', function(e){
  if (e.key === 'Enter' && window.regionsLayer) {
    const center = map.getCenter();
    window.regionsLayer.eachLayer(function(layer){
      if (layer && layer.getBounds && layer.getBounds().contains(center)) {
        const props = (layer.feature && layer.feature.properties) ? layer.feature.properties : {};
        for (const k of LINK_CANDIDATES) {
          if (props[k] && props[k].toString && props[k].toString().trim().length) {
            openInTopWindow(props[k]); return;
          }
        }
        if (props.slug && props.slug.toString().trim()) { openInTopWindow('/' + props.slug.toString().trim()); return; }
      }
    });
  }
});
</script>
</body>
</html>
