<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HAF Übersichtskarte</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html,body { height:100%; margin:0; background:#ffffff; }
    #map { width:100%; height:100vh; background:#ffffff; } 

    .legend { background: white; padding:8px 10px; border-radius:6px; box-shadow:0 1px 6px rgba(0,0,0,0.15); font-size:14px; }
    .legend .item { display:flex; align-items:center; gap:8px; margin-bottom:6px; }
    .legend .swatch { width:18px; height:12px; border-radius:2px; display:inline-block; }

    .leaflet-tooltip {
      z-index: 100000 !important;
      pointer-events: none;
    }

    @media (max-width:700px){ .legend { font-size:13px; padding:6px 8px; } }
  </style>
</head>
<body>
<div id="map" role="application" aria-label="Interaktive Übersichtskarte"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
/* CONFIG */
const REGIONS_GEOJSON_FILE = 'regionen.geojson';
const AUSTRIA_GEOJSON_FILE = 'bundeslaender.geojson';

const COLOR_FORERUNNER = "#7b8ca0";
const COLOR_FOLLOWER   = "#a1bdda";
const COLOR_DEFAULT    = "#6c757d";

const LINK_CANDIDATES = ['url','website','link','homepage','href','site','website_url','portal','web','uri','home'];

const map = L.map('map', { minZoom: 6, maxZoom: 13, scrollWheelZoom: true }).setView([47.5,13.3],7);

map.createPane('countryPane'); map.getPane('countryPane').style.zIndex = 200;
map.createPane('regionsPane'); map.getPane('regionsPane').style.zIndex = 650;
if (map.getPane('tooltipPane')) map.getPane('tooltipPane').style.zIndex = 1200;

/* Open in top window helper */
function openInTopWindow(url) {
  if (!url) return false;
  url = url.toString().trim();
  if (/^\/[^\/]/.test(url)) { try { window.top.location.href = url; } catch(e){ window.location.href = url; } return true; }
  if (!/^[a-zA-Z]+:\/\//.test(url)) url = 'https://' + url;
  try { window.top.location.href = url; } catch(e) { window.location.href = url; }
  return true;
}

/* Styles */
function austriaStyle(feature) {
  return {
    color: '#ffffff',
    weight: 2,
    fillColor: '#e1e1e1',
    fillOpacity: 1,
    interactive: false,
    pane: 'countryPane'
  };
}
function styleByType(feature) {
  const t = (feature.properties?.type || '').toLowerCase();
  let fill = COLOR_DEFAULT;
  if (t === 'forerunner') fill = COLOR_FORERUNNER;
  if (t === 'follower')   fill = COLOR_FOLLOWER;
  return {
    color: '#ffffff',
    weight: 2,
    fillColor: fill,
    fillOpacity: 1,
    className: 'region-polygon',
    pane: 'regionsPane'
  };
}

/* === DEBUG HELPERS === */
function collectCoordinatesFromGeoJSON(geojson) {
  const coords = [];
  function walk(g) {
    if (!g) return;
    const type = g.type;
    if (type === "Point") coords.push(g.coordinates);
    else if (type === "MultiPoint" || type === "LineString") g.coordinates.forEach(c => coords.push(c));
    else if (type === "Polygon") g.coordinates.forEach(r => r.forEach(c => coords.push(c)));
    else if (type === "MultiLineString") g.coordinates.forEach(ls => ls.forEach(c => coords.push(c)));
    else if (type === "MultiPolygon") g.coordinates.forEach(poly => poly.forEach(r => r.forEach(c => coords.push(c))));
    else if (type === "GeometryCollection") g.geometries.forEach(gg => walk(gg));
  }
  if (geojson.type === "FeatureCollection") geojson.features.forEach(f => walk(f.geometry));
  else if (geojson.type === "Feature") walk(geojson.geometry);
  else walk(geojson);
  return coords;
}

function percentile(sortedArr, p) {
  if (!sortedArr.length) return null;
  const idx = (p/100)*(sortedArr.length-1);
  const lo = Math.floor(idx), hi = Math.ceil(idx);
  if (lo === hi) return sortedArr[lo];
  const w = idx - lo;
  return sortedArr[lo]*(1-w) + sortedArr[hi]*w;
}

/* === FIT SETTINGS === */
const MAX_FITBOUNDS_ZOOM = 13;
const FIT_PADDING = [0,0];
const OUTLIER_CUT_PERCENT = 2.5;

function computeRobustBounds(geojson) {
  const coords = collectCoordinatesFromGeoJSON(geojson);
  if (!coords.length) return null;

  const lons = coords.map(c => c[0]).filter(Number.isFinite).sort((a,b)=>a-b);
  const lats = coords.map(c => c[1]).filter(Number.isFinite).sort((a,b)=>a-b);

  if (lons.length < 6 || lats.length < 6)
    return L.latLngBounds([[lats[0], lons[0]], [lats[lats.length-1], lons[lons.length-1]]]);

  const LO = OUTLIER_CUT_PERCENT, HI = 100-OUTLIER_CUT_PERCENT;
  const minLon = percentile(lons, LO);
  const maxLon = percentile(lons, HI);
  const minLat = percentile(lats, LO);
  const maxLat = percentile(lats, HI);

  return L.latLngBounds([[minLat, minLon],[maxLat, maxLon]]);
}

/* GLOBAL */
let austriaBounds = null;

/* LOAD AUSTRIA */
fetch(AUSTRIA_GEOJSON_FILE)
  .then(r => r.json())
  .then(data => {
    const bl = L.geoJSON(data, { style: austriaStyle, interactive:false, pane:'countryPane'}).addTo(map);

    /* DEBUG: RAW LEAFLET BOUNDS */
    const rawBounds = bl.getBounds();
    console.log("RAW Leaflet Bounds:", rawBounds.toBBoxString());

    /* DEBUG: coordinate extremes */
    const coords = collectCoordinatesFromGeoJSON(data);
    const lons = coords.map(c=>c[0]).filter(Number.isFinite).sort((a,b)=>a-b);
    const lats = coords.map(c=>c[1]).filter(Number.isFinite).sort((a,b)=>a-b);

    console.log("Total coordinate points:", coords.length);
    console.log("Longitude min/max:", lons[0], lons[lons.length-1]);
    console.log("Latitude  min/max:", lats[0], lats[lats.length-1]);

    /* DEBUG: ROBUST BOUNDS */
    const robustBounds = computeRobustBounds(data);
    console.log("ROBUST Bounds (2.5% trimmed):", robustBounds?.toBBoxString?.());

    /* assign austriaBounds safely */
    if (robustBounds) {
      const valid = typeof robustBounds.isValid === "function" ? robustBounds.isValid() : true;
      if (valid) {
        austriaBounds = robustBounds;
        console.log("Used ROBUST bounds:", austriaBounds.toBBoxString());
      } else {
        austriaBounds = rawBounds;
        console.log("ROBUST invalid, using RAW bounds instead:", austriaBounds.toBBoxString());
      }
    } else {
      austriaBounds = rawBounds;
      console.log("No ROBUST bounds, using RAW:", austriaBounds.toBBoxString());
    }

    /* EXTRA DEBUG INFO */
    console.log("austriaBounds object:", austriaBounds);
    console.log("austriaBounds.getCenter():", austriaBounds?.getCenter());
    console.log("austriaBounds BBOX:", austriaBounds.toBBoxString());

    /* === TIGHT FIT (responsive, safe shrink) === */

    const SHRINK_DESKTOP = -0.03;
    const SHRINK_TABLET  = -0.015;
    const SHRINK_MOBILE  = 0;

    function getResponsiveShrink() {
      const w = window.innerWidth || document.documentElement.clientWidth || 1024;
      if (w <= 480) return SHRINK_MOBILE;
      if (w <= 900) return SHRINK_TABLET;
      return SHRINK_DESKTOP;
    }

    function safePadBounds(bounds, padAmount) {
      if (!bounds || typeof bounds.pad !== 'function') return bounds;
      try {
        const p = bounds.pad(padAmount);
        const isValid = (typeof p.isValid === 'function') ? p.isValid() : !!(p && p.getCenter);
        if (isValid) return p;
      } catch (e) {}
      return bounds;
    }

    function fitAustriaTight() {
      try { map.invalidateSize(); } catch(e){}
      if (!austriaBounds) return;
      const valid = typeof austriaBounds.isValid === "function" ? austriaBounds.isValid() : true;
      if (!valid) return;

      const shrink = getResponsiveShrink();
      const boundsToUse = safePadBounds(austriaBounds, shrink);

      const bestZoom = map.getBoundsZoom(boundsToUse, false);
      const zoomTo = Math.min(bestZoom, MAX_FITBOUNDS_ZOOM);

      map.setView(boundsToUse.getCenter(), zoomTo, { animate: false });

      setTimeout(() => {
        try {
          map.fitBounds(boundsToUse, { padding: FIT_PADDING, maxZoom: MAX_FITBOUNDS_ZOOM, animate: false });
        } catch (e) {}
      }, 30);

      console.log("FITTIGHT → shrink:", shrink, 
                  "bounds:", boundsToUse.toBBoxString(),
                  "zoom:", zoomTo);
    }

    setTimeout(fitAustriaTight, 180);

    window.addEventListener('resize', () => {
      if (window.__fit_timeout) clearTimeout(window.__fit_timeout);
      window.__fit_timeout = setTimeout(() => fitAustriaTight(), 160);
    });

  });

/* REGIONS & INTERACTION */
window.regionsLayer = null;

function onEachRegion(feature, layer) {
  const type = (feature.properties?.type || '').toLowerCase();
  const name = feature.properties?.name || '(kein Name)';
  let prefix = '';
  if (type === 'forerunner') prefix = 'Forerunner-Region ';
  if (type === 'follower')   prefix = 'Follower-Region ';

  layer.bindTooltip(prefix + name, { sticky:true, direction:'auto', pane:'tooltipPane' });

  layer.on({
    click(e) {
      const props = feature.properties || {};
      for (const k of LINK_CANDIDATES)
        if (props[k]?.toString().trim()) return openInTopWindow(props[k]);
      if (props.slug) return openInTopWindow('/'+props.slug.trim());
    }
  });
}

function createRegionsLayer(data) {
  window.regionsLayer = L.geoJSON(data, {
    style: styleByType,
    onEachFeature: onEachRegion,
    pane: 'regionsPane'
  }).addTo(map);
}

fetch(REGIONS_GEOJSON_FILE)
  .then(r => r.json())
  .then(data => createRegionsLayer(data));

/* Legend */
const legend = L.control({ position: 'bottomright' });
legend.onAdd = function(){
  const div = L.DomUtil.create('div','legend');
  div.innerHTML = '<strong>Legende</strong>';
  const add = (color,label) => {
    const i = document.createElement('div'); i.className='item';
    const sw = document.createElement('span'); sw.className='swatch'; sw.style.background=color;
    const txt = document.createElement('span'); txt.textContent=label;
    i.appendChild(sw); i.appendChild(txt); div.appendChild(i);
  };
  add(COLOR_FORERUNNER,'Forerunner-Region');
  add(COLOR_FOLLOWER,'Follower-Region');
  return div;
};
legend.addTo(map);

</script>
</body>
</html>
