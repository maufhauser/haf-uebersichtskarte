<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HAF Übersichtskarte — no jump</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html,body{height:100%;margin:0;background:#fff}
    /* Karte füllt Viewport, initial versteckt (opacity 0), wird sichtbar sobald ready */
    #map{width:100%;height:100vh;display:block;margin:0;padding:0;box-sizing:border-box;background:#fff;opacity:0;transition:opacity .18s ease}
    #map.ready{opacity:1}

    /* kleine Legende-Stile (optional) */
    .legend{background:#fff;padding:8px;border-radius:6px;box-shadow:0 1px 6px rgba(0,0,0,.12);font-size:14px}
    .swatch{display:inline-block;width:18px;height:12px;border-radius:2px;margin-right:8px;vertical-align:middle}

    /* Falls attributionControl irgendwo sichtbar bleibt: verstecken */
    .leaflet-control-attribution{display:none !important}
  </style>
</head>
<body>
<div id="map" role="application" aria-label="Interaktive Übersichtskarte"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
/*
  Behaviour:
  - Load AUSTRIA GEOJSON first
  - Create map only after bounds known -> no initial zoom jump
  - Keep a small CSS fallback (opacity) to prevent flashes
  - Transparent tilelayer so Leaflet doesn't add extra whitespace
  - Load regions after map exists
  - Click on region opens first matching link property (iframe-safe)
*/

/* Files */
const AUSTRIA_GEOJSON_FILE = 'bundeslaender.geojson';
const REGIONS_GEOJSON_FILE = 'regionen.geojson';

/* Colours */
const COLOR_FORERUNNER = '#487367';
const COLOR_FOLLOWER   = '#e9e3d7';
const COLOR_DEFAULT    = '#6c757d';

/* Link preference */
const LINK_FIELDS = ['url','website','link','homepage','href','site','portal','web','uri','home','slug'];

/* Fit settings */
const MAX_FIT_ZOOM = 13;
const FIT_PADDING = [0,0];

/* helper: open top window (iframe-friendly) */
function openInTopWindow(url){
  if(!url) return false;
  url = String(url).trim();
  if(/^\/[^\/]/.test(url)){
    try{ window.top.location.href = url; }catch(e){ window.location.href = url; }
    return true;
  }
  if(!/^[a-zA-Z]+:\/\//.test(url)) url = 'https://' + url;
  try{ window.top.location.href = url; }catch(e){ window.location.href = url; }
  return true;
}

/* geojson helpers for robust bounds (small helper re-used if needed) */
function collectCoords(geojson){
  const pts = [];
  function walk(g){
    if(!g) return;
    const t = g.type;
    if(t==='Point') pts.push(g.coordinates);
    else if(t==='LineString' || t==='MultiPoint') g.coordinates.forEach(c=>pts.push(c));
    else if(t==='Polygon') g.coordinates.forEach(r=>r.forEach(c=>pts.push(c)));
    else if(t==='MultiLineString') g.coordinates.forEach(ls=>ls.forEach(c=>pts.push(c)));
    else if(t==='MultiPolygon') g.coordinates.forEach(poly=>poly.forEach(r=>r.forEach(c=>pts.push(c))));
    else if(t==='GeometryCollection') g.geometries.forEach(gg=>walk(gg));
  }
  if(geojson.type==='FeatureCollection') geojson.features.forEach(f=>walk(f.geometry));
  else if(geojson.type==='Feature') walk(geojson.geometry);
  else walk(geojson);
  return pts;
}

/* small style functions */
function austriaStyle(){ return { color:'#fff', weight:2, fillColor:'#eaeaea', fillOpacity:1, interactive:false }; }
function regionStyle(feature){
  const t = (feature && feature.properties && feature.properties.type || '').toLowerCase();
  let fill = COLOR_DEFAULT;
  if(t==='forerunner') fill = COLOR_FORERUNNER;
  if(t==='follower') fill = COLOR_FOLLOWER;
  return { color:'#fff', weight:2, fillColor:fill, fillOpacity:1 };
}

/* function to do tight fit to bounds (no animation) */
function fitTightTo(mapInstance, bounds){
  try{ mapInstance.invalidateSize(); }catch(e){}
  if(!bounds) return;
  const bestZoom = mapInstance.getBoundsZoom(bounds, false);
  const zoomTo = Math.min(bestZoom, MAX_FIT_ZOOM);
  mapInstance.setView(bounds.getCenter(), zoomTo, { animate:false });
  // fallback fitBounds for safety in weird layouts
  setTimeout(()=> {
    try{ mapInstance.fitBounds(bounds, { padding: FIT_PADDING, maxZoom: zoomTo, animate:false }); }catch(e){}
  }, 20);
}

/* create map AFTER loading austria geojson to avoid jump */
fetch(AUSTRIA_GEOJSON_FILE)
  .then(r => { if(!r.ok) throw new Error('load fail'); return r.json(); })
  .then(austriaGeo => {
    // compute bounds from geo
    const tmpLayer = L.geoJSON(austriaGeo); // not added yet
    const bounds = tmpLayer.getBounds();

    // now create the map (attributionControl false)
    const map = L.map('map', { minZoom:6, maxZoom:13, attributionControl:false, scrollWheelZoom:true });
    // expose globally if other scripts expect window.map
    window.map = map;

    // transparent 1x1 tile so Leaflet behaves (no extra white padding), but visually invisible
    L.tileLayer('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8z8AIAgMAnwPf4gAAAABJRU5ErkJggg==', {
      minZoom:6, maxZoom:13, attribution:''
    }).addTo(map);

    // add panes for z-index control (optional but keeps order)
    map.createPane('countryPane'); map.getPane('countryPane').style.zIndex = 200;
    map.createPane('regionsPane'); map.getPane('regionsPane').style.zIndex = 650;
    if(map.getPane('tooltipPane')) map.getPane('tooltipPane').style.zIndex = 1200;

    // add austria layer for background (non-interactive)
    const austriaLayer = L.geoJSON(austriaGeo, { style: austriaStyle, pane:'countryPane' }).addTo(map);

    // fit tightly (no jump)
    fitTightTo(map, bounds);

    // show map (CSS fade-in)
    try{ document.getElementById('map').classList.add('ready'); }catch(e){}

    /* -- now load interactive regions -- */
    fetch(REGIONS_GEOJSON_FILE)
      .then(r2 => { if(!r2.ok) throw new Error('regions load fail'); return r2.json(); })
      .then(regionGeo => {
        L.geoJSON(regionGeo, {
          style: regionStyle,
          onEachFeature: function(feature, layer){
            const name = (feature.properties && (feature.properties.name || feature.properties.title)) || '(Region)';
            layer.bindTooltip(name, { sticky:true, direction:'auto', pane:'tooltipPane' });
            layer.on('click', function(){
              const props = feature.properties || {};
              for(const k of LINK_FIELDS){
                if(props.hasOwnProperty(k) && props[k] != null && String(props[k]).trim().length){
                  if(k === 'slug'){ openInTopWindow('/' + String(props[k]).trim()); return; }
                  openInTopWindow(props[k]);
                  return;
                }
              }
            });
          },
          pane:'regionsPane'
        }).addTo(map);

        // re-apply tight fit after regions added (keeps final view stable)
        setTimeout(()=> fitTightTo(map, bounds), 40);

        // re-fit on resize
        window.addEventListener('resize', () => {
          if(window.__fit_timeout) clearTimeout(window.__fit_timeout);
          window.__fit_timeout = setTimeout(()=> fitTightTo(map, bounds), 160);
        });
      })
      .catch(err => {
        console.warn('regionen.geojson load failed', err);
        // still add resize handler to keep responsiveness
        window.addEventListener('resize', () => { if(window.__fit_timeout) clearTimeout(window.__fit_timeout); window.__fit_timeout = setTimeout(()=> fitTightTo(map, bounds), 160); });
      });

  })
  .catch(err => {
    console.error('bundeslaender.geojson load failed', err);
    // fallback: create map anyway so page isn't broken (less ideal)
    const map = L.map('map', { minZoom:6, maxZoom:13, attributionControl:false });
    window.map = map;
    L.tileLayer('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8z8AIAgMAnwPf4gAAAABJRU5ErkJggg==').addTo(map);
    document.getElementById('map').classList.add('ready');
  });

/* Minimal legend (optional) */
(function addLegend(){
  const legend = L.control({ position: 'bottomright' });
  legend.onAdd = function(){
    const d = L.DomUtil.create('div','legend');
    d.innerHTML = '<div><span class="swatch" style="background:'+COLOR_FORERUNNER+'"></span>Forerunner</div><div><span class="swatch" style="background:'+COLOR_FOLLOWER+'"></span>Follower</div>';
    return d;
  };
  // wait until map exists then add (or try later)
  const tryAdd = () => { if(window.map) legend.addTo(window.map); else setTimeout(tryAdd, 200); };
  tryAdd();
})();
</script>
</body>
</html>
